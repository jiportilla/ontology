#!/usr/bin/env python
# -*- coding: UTF-8 -*-


from base import BaseObject


class RemoveOverlappingTags(BaseObject):
    """
    Purpose:
        Some Annotations (tags) overlap with other Annotations (tags)
    Example 1:
        The tag "Windows Server 2003" overlaps with:
            "Windows"
            "Windows Server"
            "Server 2003"
        Assuming the annotation model produces all four tags:
            [ "Windows", "Windows Server", "Server 2003", "Windows Server 2003"]
        This function will remove all the overlapped tags, to leave only:
            [ "Windows Server 2003"]
    Example 2:
        The reality is slightly more complicated because each tag has
            an associated confidence level generated by the annotation model
        The actual input to this function is a list of tag tuples:
            [   ('windows', 100),
                ('windows server', 90),
                ('server 2003', 85),
                ('windows server 2003', 70) ]
        The tuple is composed of
            1.  the tag                     tuple[0]
            2.  the confidence level        tuple[1]
        The function will find overlapping tags, but only remove the smaller tags
            if the confidence level of the larger tags is sufficiently high
        To take an extreme example, the tag
            ("AWS Certification for Cloud Computing", 45)
        certainly overlaps with
            ("Cloud Computing", 95)
        but the longer tag only has 45% chance of being accurate
            and the shorter tag has a 95% chance of being accurate.
        because the delta between these two tags is sufficiently high,
            they are not considered to be overlapping
    """

    __results = []

    def __init__(self,
                 tag_tuples: list,
                 score_interval: int = 10,
                 is_debug: bool = False):
        """
        Created:
            21-Aug-2019
            craig.trim@ibm.com
            *   refactored out of text-parser
                https://github.ibm.com/GTS-CDO/unstructured-analytics/issues/796
        """
        BaseObject.__init__(self, __name__)
        self._is_debug = is_debug
        self._score_interval = score_interval
        self._process(tag_tuples)

    def results(self) -> list:
        return self.__results

    def _compare_scores(self,
                        tuple_1: tuple,
                        tuple_2: tuple) -> bool:
        """
        Purpose:
            Compare the confidence scores of two tags
        :param tuple_1:
            the first tuple     (tag, score)
        :param tuple_2:
            the second tuple    (tag, score)
        :return:
            True        if the interval is within the defined tag-delta
            False       if the interval is outside the defined tag-delta
        """
        score_1 = tuple_1[1]  # (tag, score)
        score_2 = tuple_2[1]  # (tag, score)
        return abs(score_1 - score_2) < self._score_interval

    def _process(self,
                 tag_tuples: list) -> None:
        """
        :param tag_tuples:
            a list of tag tuples
            Sample Input:
                [   ('aws', 100),
                    ('aws certification', 73),
                    ('plan', 73),
                    ('financial plan', 73) ]
            Sample Results:
                [   ('aws certification', 73),
                    ('financial plan', 73) ]
        """
        subsumed = set()
        for tt1 in tag_tuples:
            for tt2 in tag_tuples:
                if tt1[0] == tt2[0]:
                    continue
                if tt1[0] in tt2[0] and self._compare_scores(tt1, tt2):
                    subsumed.add(tt1)

        subsumed_tags = [x[0] for x in subsumed]
        tag_tuples = [x for x in tag_tuples if x[0] not in subsumed_tags]

        self.__results = tag_tuples
